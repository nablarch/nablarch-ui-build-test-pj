'use strict';

// 引数チェック
console.log(process.argv);
if (process.argv.length < 3) {
  console.log("Usage: node ui_build.js <project's conf file path> [clean] [genless] [nablarchDevelopMode]");
  process.exit(1);
}

var cleanMode = (process.argv.indexOf('clean') > 0);
var generateLessMode = (process.argv.indexOf('genless') > 0);
var developMode = (process.argv.indexOf('nablarchDevelopMode') > 0);

require('sugar');
require('shelljs/global');
var fs = require('fs');
var path = require('path');

// コンフィグファイルチェック
var PJ_CONF_PATH = process.argv[2];
if (!fs.existsSync(PJ_CONF_PATH)) {
  console.log("Project's conf file is not found.");
  process.exit(1);
}

// 定数定義
var DEFAULT_PJ_CONF = {
    "pathSettings" :
    { "projectRootPath"   : PJ_CONF_PATH
    , "demoProjectPath"   : "ui_demo"
    , "testProjectPath"   : "ui_test"
    , "pluginProjectPath" : "ui_plugins"
    }
  , "cssMode" : ["wide", "compact", "narrow"]
  , "plugins" : [{"pattern": ".*"}]
  , "imgcopy" :
    { "fromdirs" : []
    , "todirs" : []
    }
  , "excludedirs" : ["^\\.[^\\.]+"]
};

var pjConf;
if (fs.statSync(PJ_CONF_PATH).isFile()) {
  // 設定ファイルを読み込み
  pjConf = readJsonFile(path.resolve(PJ_CONF_PATH));

  // 未設定項目にデフォルト値を設定
  pjConf.pathSettings = pjConf.pathSettings || DEFAULT_PJ_CONF.pathSettings;
  var pathSettings = pjConf.pathSettings;
  var defPathSettings = DEFAULT_PJ_CONF.pathSettings;
  pathSettings.demoProjectPath = pathSettings.demoProjectPath || defPathSettings.demoProjectPath;
  pathSettings.testProjectPath = pathSettings.testProjectPath || defPathSettings.testProjectPath;
  pathSettings.pluginProjectPath = pathSettings.pluginProjectPath || defPathSettings.pluginProjectPath;
  pjConf.cssMode = pjConf.cssMode || DEFAULT_PJ_CONF.cssMode;
  pjConf.plugins = pjConf.plugins || DEFAULT_PJ_CONF.plugins;
  pjConf.imgcopy = pjConf.imgcopy || DEFAULT_PJ_CONF.imgcopy;
  pjConf.excludedirs = pjConf.excludedirs || DEFAULT_PJ_CONF.excludedirs;

} else {
  pjConf = DEFAULT_PJ_CONF;
}

// 必須設定項目チェック
if (!pjConf.pathSettings.webProjectPath) {
  console.log('"pathSettings.webProjectPath" is required. conf-file:' + PJ_CONF_PATH);
  process.exit(1);
}

var PJ_ROOT_PATH     = pjConf.pathSettings.projectRootPath
  , PJ_WEBPRJ_PATH   = path.join(PJ_ROOT_PATH, pjConf.pathSettings.webProjectPath)
  , UI_DEMO_PATH     = path.join(PJ_ROOT_PATH, pjConf.pathSettings.demoProjectPath)
  , UI_TEST_PATH     = path.join(PJ_ROOT_PATH, pjConf.pathSettings.testProjectPath)
  , UI_PLUGINS_PATH  = path.join(PJ_ROOT_PATH, pjConf.pathSettings.pluginProjectPath)
  , UI_MODULE_PATH   = path.join(UI_PLUGINS_PATH , 'node_modules');

var INTEGRATION_LESS_LIST = Array.create(pjConf.cssMode);

var JS = 'node';
var LS = '\n';

var LIB_DEPLOY_PATHS     = [UI_DEMO_PATH, UI_TEST_PATH, PJ_WEBPRJ_PATH];
var BUILD_TARGET_PATHS   = [UI_DEMO_PATH, UI_TEST_PATH, PJ_WEBPRJ_PATH];

var UI_PUBLIC_DEPLOY_PATHS = [UI_DEMO_PATH, UI_TEST_PATH, PJ_WEBPRJ_PATH];
var UI_LOCAL_DEPLOY_PATHS  = [UI_DEMO_PATH, UI_TEST_PATH];
var UI_TEST_DEPLOY_PATHS   = [UI_TEST_PATH];

// 開発モード
if (developMode) {
  LIB_DEPLOY_PATHS        = [UI_TEST_PATH];
  BUILD_TARGET_PATHS      = [UI_TEST_PATH];
  UI_PUBLIC_DEPLOY_PATHS  = [UI_TEST_PATH];
  UI_LOCAL_DEPLOY_PATHS   = [UI_TEST_PATH];
  UI_TEST_DEPLOY_PATHS    = [UI_TEST_PATH];
}

var DEPLOY_PATHS = Object.extended({
  'ui_public' : UI_PUBLIC_DEPLOY_PATHS
, 'ui_local'  : UI_LOCAL_DEPLOY_PATHS
, 'ui_test'   : UI_TEST_DEPLOY_PATHS
});

var DEPLOY_ORDER = ['ui_public', 'ui_local', 'ui_test'];

var LAST_BUILD_FILE_LIST = path.resolve(path.join(UI_PLUGINS_PATH, 'lastBuildFileList.json'));

var libraryDeployMappings = pjConf.libraryDeployMappings || {};

var TOOLS_DIR_PATH   = 'tools'
  , SCRIPT_DIR_PATH  = 'js'
  , CSS_BUILT_PATH   = path.join('css', 'built')
  , AUTOCONF_JS_PATH = path.join(TOOLS_DIR_PATH, 'build', 'lib', 'autoconf.js')
  , RSCRIPT_JS_PATH  = getPackageBinPath('requirejs', 'r.js')
  , LESSC_PATH       = getPackageBinPath('less', 'lessc')
  , YUIDOC_JSON_PATH = path.join(TOOLS_DIR_PATH, 'yuidoc.json');

var UI_JS_PATH      = path.join(SCRIPT_DIR_PATH, 'nablarch', 'ui.js')
  , MINIFY_JS_PATH  = path.join(SCRIPT_DIR_PATH, 'nablarch-minify.js')
  , DEVTOOL_JS_PATH = path.join(SCRIPT_DIR_PATH, 'devtool.js')
  , DEVTOOL_CF_PATH = path.join(SCRIPT_DIR_PATH, 'build', 'devtool_conf.js')
  , IT_LESS_PATH    = path.join(UI_PLUGINS_PATH, 'css', '{1}', '{2}.less')
  , IT_CSS_PATH     = path.join(CSS_BUILT_PATH, '{1}.css')
  , IT_MINIFY_PATH  = path.join(CSS_BUILT_PATH, '{1}-minify.css');

var AUTOGEN_FILES = Array.create(
                     UI_JS_PATH
                   , MINIFY_JS_PATH
                   , DEVTOOL_JS_PATH
                   , DEVTOOL_CF_PATH
                   ).add(INTEGRATION_LESS_LIST.map(function(mode) {
                      return(Array.create(
                            IT_CSS_PATH.assign(mode)
                          , IT_MINIFY_PATH.assign(mode)
                          ));
                   })).flatten();

var IGNORE_REMOVED_FAILED_FILES =
  { "nablarch-dev-tool-server" : [ ".*" ]
  };

var deployedFiles = Object.extended();

var copiedCssFiles = Object.extended();

var copiedImages = [];

//--- script main --- //
function main() {
  console.log('project conf: ', pjConf);

  if (cleanMode) {
    // クリーンモード
    removeLastBuildFile();

  } else if(generateLessMode) {
    // LESSファイル作成モード
    deployModules();
    generateLess();

  } else {
    // 通常モード
    removeLastBuildFile();
    createDirs();
    deployModules();
    buildMinifyJS();
    buildDevtoolJS();
    distDevtoolJS();
    buildMinifyCSS();
    copyimg();
    createLastBuildFileList();
    showDuplicateDeployFiles();
  }
}

//----- subroutines -----//
/**
 * JSONファイルを読み込む
 */
function readJsonFile(filePath) {
  // return require(filePath);
  return eval('(' + fs.readFileSync(filePath, 'utf8') + ')');
}

/**
 * package.jsonの'bin'からバイナリファイル名を取得する
 */
function getPackageBinPath(packageName, binName) {
  var packagePath = path.join(UI_MODULE_PATH, packageName);
  var packageJsonPath = path.join(packagePath, 'package.json');
  var packageJson = readJsonFile(packageJsonPath);
  var binPath = packageJson.bin[binName];
  return path.join(packagePath, binPath);
}

/**
 * 出力先のディレクトリを作成する
 */
function createDirs() {
  console.log('createDirs:');

  mkdir('-p', UI_MODULE_PATH);
  BUILD_TARGET_PATHS.each(function(targetDir) {
    mkdir('-p', targetDir);
  });
}

/**
 * インストール対象のプラグインを抽出する
 */
function selectInstallPlugins() {
  return pjConf.plugins.map(function(confItem) {
    return ls(UI_MODULE_PATH)
    .filter(new RegExp(confItem.pattern))
    .map(function(packageName) {
      return { packageName : packageName
              , opts        : confItem };
    });
  }).exclude(function(packageInfo) {
    return packageInfo.isEmpty();
  }).flatten();
}

/**
 * 各環境にモジュールを配布する
 */
function deployModules() {
  console.log('deployModules:');

  var installPlugins = selectInstallPlugins();
  installPlugins.each(function(packageInfo) {
    var packageName = packageInfo.packageName;
    var packagePath = path.join(UI_MODULE_PATH, packageName)
      , content = ls(packagePath);

    console.log('Install plugin.', packageName);

    // 開発ライブラリのデプロイ
    DEPLOY_ORDER.each(function(key) {
      if (content.some(key)) {
        DEPLOY_PATHS[key].each(function(targetDir) {
          if (generateLessMode) {
            addCssFiles(packagePath, key, targetDir, packageInfo.opts.exclude);
          } else {
            deployFiles(packagePath, key, targetDir, packageInfo.opts.exclude);
          }
        });
      }
    });

    if (!generateLessMode) {
      // サードパーティライブラリのデプロイ
      if (libraryDeployMappings[packageName]) {
        for(var srcKey in libraryDeployMappings[packageName]){
          var srcPath = path.join(packagePath, srcKey);
          var srcFile = path.basename(srcPath);

          LIB_DEPLOY_PATHS.each(function(deployPath) {
            var dstPath = path.join(deployPath, libraryDeployMappings[packageName][srcKey]);
            var dstDir = path.dirname(dstPath);
            var dstFile = path.basename(dstPath);

            mkdir('-p', dstDir);
            copyFile(srcPath, dstDir, true);
            fs.renameSync(path.join(dstDir, srcFile), path.join(dstDir, dstFile));
          });
        }
      }
    }
  });
}

/**
 * ファイルをデプロイする
 */
function deployFiles(packagePath, key, dstRoot, excludeFiles) {
  var srcRoot = packagePath + '/' + key;
  find(srcRoot)
  .filter(function(file) {
    return isExcludeCopyFile(file, excludeFiles);
  })
  .each(function(src) {
    var dst = path.join(dstRoot, path.relative(srcRoot, src));
    if (!src.match(/\.less$/)) {
      if (fs.statSync(src).isDirectory()) {
        mkdir('-p', dst);
      } else {
        copyFile(src, dst);
        addDeployedFiles(packagePath, key, path.relative(srcRoot, src));
      }
    }
  });
}


/**
 * コピー対象のCSSを追加する
 */
function addCssFiles(packagePath, key, dstRoot, excludeFiles) {
  var srcRoot = packagePath + '/' + key;

  find(srcRoot)
  .filter(function(file) {
    return isExcludeCopyFile(file, excludeFiles);
  })
  .each(function(src) {
    if (src.match(/\.less$/)) {
      if (!copiedCssFiles[key]) {
        copiedCssFiles[key] = [];
      }
      copiedCssFiles[key].push(src);
      addDeployedFiles(packagePath, key, path.relative(srcRoot, src));
    }
  });
}

/**
 * コピー対象外ファイルを除外するフィルター
 */
function isExcludeCopyFile(file, excludeFiles) {
  var isExclude = false;
  if (excludeFiles) {
    isExclude = Array.create(excludeFiles).some(function(name) {
      return file.match(new RegExp(name));
    });
  }
  return !isExcludeDirectory(file)
      && !isExclude
      && !(fs.statSync(file).isDirectory() && file.match(/\/css\//));
}

/**
 * 除外対象ディレクトリであるかを判定する
 */
function isExcludeDirectory(file) {
  var dirs = file.replace(/\\/g, '/').split('/');
  return Array.create(dirs).any(function(dir) {
    return Array.create(pjConf.excludedirs).any(function(regexp) {
      return dir.match(new RegExp(regexp));
    });
  });
}

/**
 * デプロイ済みファイルリストに追加する
 */
function addDeployedFiles(packagePath, key, targetFile) {
  var packageName = packagePath.replace(/\\/g, '/').match(/.*\/(.*)/)[1];
  targetFile = key + '/' + targetFile.replace(/\\/g, '/');

  if (deployedFiles.has(targetFile)) {
    if (!deployedFiles[targetFile].some(packageName)) {
      console.log('  duplicate file detected!!', targetFile);
      deployedFiles[targetFile].add(packageName);
    }
  } else {
    deployedFiles[targetFile] = [packageName];
  }
}

/**
 * ファイルをコピーする
 */
function copyFile(src, dst, recurse) {
  var opt = recurse ? '-Rf' : '-f';
  cp(opt, src, dst);
  var srcStats = fs.statSync(src);
  fs.utimesSync(dst, srcStats.atime, srcStats.mtime);
}

/**
 * 開発用ツールを生成する
 */
function buildDevtoolJS() {
  console.log('buildDevtoolJS:');

  BUILD_TARGET_PATHS.each(function(targetDir) {
    var autoconfScript = path.resolve(path.join(targetDir, AUTOCONF_JS_PATH));
    if (fs.existsSync(autoconfScript)) {
      var scriptDir = path.resolve(path.join(targetDir, SCRIPT_DIR_PATH));
      var rScript = path.resolve(RSCRIPT_JS_PATH);

      var devtoolConf = path.resolve(path.join(targetDir, DEVTOOL_CF_PATH));

      mkdir('-p', path.dirname(devtoolConf));

      pushd(scriptDir);

      // js/build/devtool_conf.js を作成する
      var result = execute(JS + ' ' + autoconfScript, {silent:true});
      fs.writeFileSync(devtoolConf, result.output);

      // js/devtool.js を作成する
      execute(JS + ' ' + rScript + ' -o ' + devtoolConf);

      popd();
    };
  });
}

/**
 * ビルドされた開発用ツール(devtool.js)を配布する。
 */
function distDevtoolJS() {
  console.log('distDevtoolJS:');
  var devtooljs = path.resolve(path.join(UI_DEMO_PATH,   DEVTOOL_JS_PATH));
  var dest      = path.resolve(path.join(PJ_WEBPRJ_PATH, DEVTOOL_JS_PATH));
  cp('-f', devtooljs, dest);
}


/**
 * minifyされたJavaScriptファイルを生成する
 */
function buildMinifyJS() {
  console.log('buildMinifyJS:');

  BUILD_TARGET_PATHS.each(function(targetDir) {
    var scriptDir = path.resolve(path.join(targetDir, SCRIPT_DIR_PATH));

    var rScript = path.resolve(RSCRIPT_JS_PATH);

    var minifyJsFileName = path.basename(MINIFY_JS_PATH);
    var uiJsFile = path.resolve(path.join(targetDir, UI_JS_PATH));

    pushd(scriptDir);

    // js/nablarch/ui.js を作成する
    createIntegrationUIScript(scriptDir, uiJsFile);

    // js/nablarch-minify.js を作成する
    execute(JS + ' ' + rScript + ' -o name=nablarch.js out=' + minifyJsFileName + ' baseUrl=.');

    popd();
  });
}

/**
 * UI部品ライブラリ読み込み用の結合ファイル(js/nablarch/ui.js)を生成する
 */
function createIntegrationUIScript(relativeRootDir, targetJsFile) {
  fs.writeFileSync(targetJsFile, 'define([' + LS);
  find(path.dirname(targetJsFile))
  .filter(function(file) {
      return file.match(/.*\.js$/) && !file.match(/.*test\.js$/i);
    })
  .sortBy(function(file){
      return file.match(/.*Widget\.js$/i) ? 0 : 1;
    })
  .each(function(targetFile, index) {
    var dirname = path.dirname(path.relative(relativeRootDir, targetFile)).replace(/\\/g, '/');
    var filename = path.basename(targetFile, '.js');
    var comma = (index === 0) ? ' ' : ',';
    fs.appendFileSync(targetJsFile, comma + ' "' + dirname + "/" + filename + '"' + LS);
  });
  fs.appendFileSync(targetJsFile, '], function(Widget) { "use strict"; return { Widget: Widget }; });' + LS);
}

/**
 * minifyされたCSSファイルを生成する
 */
function buildMinifyCSS() {
  console.log('buildMinifyCSS:');

  BUILD_TARGET_PATHS.each(function(targetDir) {
    var cssDir = path.resolve(path.join(targetDir, CSS_BUILT_PATH));
    var toolsDir = path.resolve(path.join(targetDir, TOOLS_DIR_PATH));

    var rScript = path.resolve(RSCRIPT_JS_PATH);
    var lesscScript = path.resolve(LESSC_PATH);

    mkdir('-p', cssDir);

    var cssFindDir = null;
    switch (targetDir) {
      case PJ_WEBPRJ_PATH:
        cssFindDir = 'ui_public';
        break;
      case UI_DEMO_PATH:
      case UI_TEST_PATH:
        cssFindDir = 'ui_local';
        break;
    }

    INTEGRATION_LESS_LIST.each(function(targetMode) {
      //var lessFile = path.resolve(path.join(targetDir, IT_LESS_PATH.assign(targetMode)));
      var lessFile = path.resolve(IT_LESS_PATH.assign(cssFindDir, targetMode));

      var cssFile = path.resolve(path.join(targetDir, IT_CSS_PATH.assign(targetMode)));
      var cssFileName = path.basename(cssFile);

      var minifyFile = path.resolve(path.join(targetDir, IT_MINIFY_PATH.assign(targetMode)));
      var minifyFileName = path.basename(minifyFile);

      // css/built/(compact|narrow|wide).css を作成する
      pushd(toolsDir);
      var result = execute(JS + ' ' + lesscScript + ' ' + lessFile, {silent:true});
      fs.writeFileSync(cssFile, result.output);
      popd();

      // css/built/(compact|narrow|wide)-minify.css を作成する
      pushd(cssDir);
      execute(JS + ' ' + rScript + ' -o cssIn=' + cssFileName + ' out=' + minifyFileName);

      // css/built/(compact|narrow|wide)-minify.css 以外は不要なため削除する
      //rm('-f', lessFile, cssFile);
      popd();
    });
  });
}

/**
 * less読み込み用の結合ファイル(css/built/(compact|narrow|wide).less)を生成する
 */
function generateLess() {
  console.log('generateLess:');

  sortCopiedCssFiles();

  INTEGRATION_LESS_LIST.each(function(targetMode) {
    createIntegrationLess(targetMode, true);
    createIntegrationLess(targetMode, false);
  });

  /**
   * CSSファイルリストをソートする
   */
  function sortCopiedCssFiles() {
    var dispModeRegexp = new RegExp('.*(' + INTEGRATION_LESS_LIST.join('|') + ')$');

    copiedCssFiles.keys(function(key) {
      var targetCssFiles = copiedCssFiles[key];

      // パッケージグループごとの処理
      var pluginGroups = Object.extended();
      targetCssFiles.each(function(n) {
        var packageName = n.match(/.*\/node_modules\/([^\/]+)\//)[1];
        var packageGroup = packageName.match(/(.*)-.*$/)[1];
        if (pluginGroups[packageGroup]) {
          pluginGroups[packageGroup].push(n);
        } else {
          pluginGroups[packageGroup] = [n];
        }
      });

      // 各パッケージグループのbaseを先頭に移動
      pluginGroups.keys(function(packageGroup) {
        var pluginList = pluginGroups[packageGroup].sortBy(function(n) {
          var packageName = n.match(/.*\/node_modules\/([^\/]+)\//)[1];
          var packageSuffix = packageName.match(/.*-(.*)$/)[1];
          if (packageSuffix === 'base') {
            return 0;
          } else {
            return 1;
          }
        });
        pluginGroups[packageGroup] = pluginList;
      });

      targetCssFiles = pluginGroups.values().flatten();

      // パッケージごとの処理
      var pluginPackages = Object.extended();
      targetCssFiles.each(function(n) {
        var packageName = n.match(/.*\/node_modules\/([^\/]+)\//)[1];
        if (pluginPackages[packageName]) {
          pluginPackages[packageName].push(n);
        } else {
          pluginPackages[packageName] = [n];
        }
      });

      // 各パッケージの表示モード付きファイルを最後尾に移動
      pluginPackages.keys(function(packageName) {
        var pluginList = pluginPackages[packageName].sortBy(function(n) {
          var hasDispMode = path.basename(n, '.less').match(dispModeRegexp);
          if (hasDispMode) {
            return 1;
          } else {
            return 0;
          }
        });
        pluginPackages[packageName] = pluginList;
      });

      targetCssFiles = pluginPackages.values().flatten();

      // nablarch-cssを抽出
      var nablarchCssFiles = targetCssFiles
        .filter(function(n) {
          var packageName = n.match(/.*\/node_modules\/([^\/]+)\//)[1];
          return packageName.match(/nablarch-css-.*/);

      }).sortBy(function(n) {
        // nablarch-cssの中でも順位付け
        var packageName = n.match(/.*\/node_modules\/([^\/]+)\//)[1];
        if (packageName.match(/nablarch-css-core/)) {
          if (n.endsWith('reset.less')) {
            return 0;
          } else {
            return 1;
          }
        } else if (packageName.match(/nablarch-css-.*/)) {
          return 2;
        }
      });

      // nablarchのcssを一旦削除し、先頭へ追加
      targetCssFiles = targetCssFiles.subtract(nablarchCssFiles);
      targetCssFiles = targetCssFiles.add(nablarchCssFiles, 0);

      copiedCssFiles[key] = targetCssFiles;
    });
  }

  /**
   * less読み込み用の結合ファイル(css/built/(compact|narrow|wide).less)を生成する
   */
  function createIntegrationLess(targetMode, isLocal) {
    var dispModeRegexp = new RegExp('.*(' + INTEGRATION_LESS_LIST.join('|') + ')$');

    var binDir = process.cwd();

    var targetLessFile = IT_LESS_PATH.assign(isLocal ? 'ui_local' : 'ui_public', targetMode);
    var targetCssDir = path.dirname(targetLessFile);

    console.log('Create less.', targetLessFile);

    rm('-f', targetLessFile);
    mkdir('-p', targetCssDir);

    var targetCssFile = copiedCssFiles['ui_public'].clone();
    if (isLocal && copiedCssFiles['ui_local']) {
      targetCssFile.add(copiedCssFiles['ui_local']);
    }

    targetCssFile
    .filter(function(file) {
        return !file.match(/.*\/built\/.*/)
            && file.match(/.*\.less$/);
    })
    .each(function(targetFile) {
      var targetFilePath = path.resolve(path.join(binDir, targetFile));
      var dirname = path.dirname(path.relative(path.resolve(targetCssDir), targetFilePath)).replace(/\\/g, '/');
      var filename = path.basename(targetFile, '.less');
      targetFile = dirname + "/" + filename;
      if (filename.match(dispModeRegexp)) {
        if (filename.endsWith(targetMode)) {
          // 表示モード毎のファイルは対象モードのみ
          fs.appendFileSync(targetLessFile, '@import "' + targetFile + '";' + LS, {'flag' : 'a+'});
        }
      } else {
        // 共通ファイルはすべて
        fs.appendFileSync(targetLessFile, '@import "' + targetFile + '";' + LS, {'flag' : 'a+'});
      }
    });
  }
}


/**
 * 外部コマンドを実行する
 */
function execute(cmd, options) {
  var result = exec(cmd, options);
  if (result.code !== 0) {
    console.log('Command execution failed. RC:[' + result.code + '] CMD:[' + cmd + ']');
    console.log(result.output);
    process.exit(result.code);
  }
  return result;
}

/**
 * 最後にビルドしたファイルのリストを生成する
 */
function createLastBuildFileList() {
  console.log('createLastBuildFileList:');

  var DEPLOY_TARGETS = new RegExp('(' + DEPLOY_PATHS.keys().join('|') + ')\/');

  var lastBuildFileList = {};

  // 自動生成ファイル
  lastBuildFileList['_autogen'] = {'files' : AUTOGEN_FILES};

  // ドキュメント
  var yuidocConf = path.resolve(path.join(UI_TEST_PATH, YUIDOC_JSON_PATH));
  if (fs.existsSync(yuidocConf)) {
    var yuidocOutDir = readJsonFile(yuidocConf).options.outdir;
    lastBuildFileList['_autogen']['files'].add(yuidocOutDir);
  }

  // コピー画像ファイル
  lastBuildFileList['_autogen']['files'].add(copiedImages);

  ls(UI_MODULE_PATH)
  .filter(function(targetModuleName) {
    // ディレクトリのみ
    var targetModule = path.join(UI_MODULE_PATH, targetModuleName);
    return fs.statSync(targetModule).isDirectory();
  })
  .each(function(targetModuleName) {
    // 抽出したモジュールごとに処理
    var listMap = {};

    if (libraryDeployMappings[targetModuleName]) {
      // サードパーティライブラリ
      listMap['files'] = Object.extended(libraryDeployMappings[targetModuleName]).values();

    } else {
      // 開発ライブラリ
      var targetModule = path.join(UI_MODULE_PATH, targetModuleName);
      find(targetModule)
      .filter(function(targetFilePath) {
        // svn以外かつ各環境にコピーするファイルのみが対象
        return !isExcludeDirectory(targetFilePath)
            && targetFilePath.match(DEPLOY_TARGETS);
      })
      .each(function(targetFilePath) {
        // ファイル情報を対象のリストに格納する
        var targetFile = path.relative(targetModule, targetFilePath);
        var listName = targetFile.split(path.sep)[0];
        var relativePath = targetFile.remove(listName + path.sep);
        if (fs.statSync(targetFilePath).isFile()) {
          if (!listMap[listName]) {
            listMap[listName] = [];
          }
          listMap[listName].push(relativePath);
        }
      });
    }

    // モジュールに含まれるファイル一覧を出力
    lastBuildFileList[targetModuleName] = listMap;
  });

  fs.writeFileSync(LAST_BUILD_FILE_LIST,
      JSON.stringify(lastBuildFileList, function(key, value) {
        return (typeof value === 'string') ? value.replace(/\\/g, '/') : value;
      }, 0));
}

/**
 * 最後にビルドしたファイルを削除する
 */
function removeLastBuildFile() {
  console.log('removeLastBuildFile:');

  if (!fs.existsSync(LAST_BUILD_FILE_LIST)) {
    return;
  }
  var lastBuildFileList = readJsonFile(LAST_BUILD_FILE_LIST);

  for (var moduleName in lastBuildFileList) {
    // 全モジュール
    for (var listName in lastBuildFileList[moduleName]) {
      // 全リスト
      var targetDeployPaths = DEPLOY_PATHS[listName] || UI_PUBLIC_DEPLOY_PATHS;
      targetDeployPaths.each(function(targetDir) {
        // 対象リストのデプロイ先を取得
        var targetDirAbsolutePath = path.resolve(targetDir);
        lastBuildFileList[moduleName][listName].each(function(targetFile) {
          // 対象ファイルを個別に確認
          var targetFilePath = path.resolve(path.join(targetDir, targetFile));
          if (fs.existsSync(targetFilePath)) {
            try {
              // ファイルを削除
              removeFile(targetFilePath);

              // 親ディレクトリが空なら削除
              var parentFilePath = path.dirname(targetFilePath);
              while (parentFilePath != targetDirAbsolutePath
                  && fs.existsSync(parentFilePath)
                  && fs.readdirSync(parentFilePath).isEmpty()) {
                removeFile(parentFilePath);
                parentFilePath = path.dirname(parentFilePath);
              }
            } catch (e) {
              if (isIgnoreRemovedFailed(moduleName, targetFile)) {
                console.log('remove file failed.', e);
              } else {
                throw e;
              }
            }
          }
        });
      });
    }
  }

  /**
   * ファイルを削除します
   */
  function removeFile(p) {
    if (fs.statSync(p).isDirectory()) {
      if (fs.readdirSync(p).isEmpty()) {
        fs.rmdirSync(p);
      }
    } else {
      fs.unlinkSync(p);
    }
  }

  /**
   * 対象ファイルが削除に失敗しても無視するかを返します
   */
  function isIgnoreRemovedFailed(moduleName, file) {
    var ignoreFileList = IGNORE_REMOVED_FAILED_FILES[moduleName];
    if (ignoreFileList) {
      return ignoreFileList.some(function(r) {
        return file.match(new RegExp(r));
      });
    }
    return false;
  }
}

/**
 * 画像ファイルをコピーする
 */
function copyimg() {
  console.log('copyimg:');

  var fromdirs = pjConf.imgcopy.fromdirs;
  var todirs   = pjConf.imgcopy.todirs;

  // コピー実行
  BUILD_TARGET_PATHS.forEach(function(buildTargetDir) {
    fromdirs.forEach(function(fromdir){
      todirs.forEach(copy(buildTargetDir, fromdir));
    });
  });

  /**
   *  callback のヘルパー。
   */
  function copy(buildTargetDir, fromdir) {
    return function (todir) {
      copydir(buildTargetDir, fromdir, todir);
    };
  }

  /**
   * ディレクトリの内容をコピーする。
   */
  function copydir(buildTarget, from, to) {
    var fromdir = path.resolve(buildTarget, from);
    var todir = path.resolve(buildTarget, to);

    if (fs.existsSync(fromdir)) {
      fs.readdirSync(fromdir)
      .filter(function(file) {
        return !isExcludeDirectory(file);
      })
      .forEach(cp_r);
    }

    /**
     * 再帰的にコピーする。
     * ファイルが存在する場合はスキップする。
     */
    function cp_r(file) {
      var frompath = path.join(fromdir, file)
        , topath   = path.join(todir, file)
        , stat = fs.statSync(frompath);
      if (stat.isDirectory()){
        if (!fs.existsSync(topath)) {
          fs.mkdir(topath);
        }
        copydir(buildTarget, frompath, topath);
      } else if (stat.isFile()) {
        if (!fs.existsSync(topath)) {
          copyfile(frompath,  topath);
          copiedImages.push(path.join(to, file));
        }
      }
    }

    /**
     * ファイルをコピーする。
     */
    function copyfile(from, to) {
      var parentDir = path.dirname(to);
      if (!fs.existsSync(parentDir)) {
        fs.mkdir(parentDir);
      }
      fs.createReadStream(from).pipe(fs.createWriteStream(to));
    }
  }
}

/**
 * プラグイン間で重複しているファイルを表示する。
 */
function showDuplicateDeployFiles() {
  var duplicatedDeployFiles = Object.extended();
  deployedFiles.keys(function(key) {
    if (deployedFiles[key].length > 1) {
      duplicatedDeployFiles[key] = deployedFiles[key];
    };
  });
  if (duplicatedDeployFiles.size() > 0) {
    console.log();
    console.log('duplicate file detected!!');
    console.log(JSON.stringify(duplicatedDeployFiles, null, 2));
  }
}

main();

